<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="main.css">

<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(68262424, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/68262424" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/src/lang-go.js"></script>
<body>
    <center><a href=../>index</a></center>
<table>

<tr class=withcomment>
    
    <td class=comment rowspan=1>
         Reading and writing files are basic tasks needed for many Go programs. First we&#39;ll look at some examples of reading files.</td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">package main</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=8>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">import (</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;bufio&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;fmt&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;io&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;io/ioutil&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;os&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=5>
         Reading files requires checking most calls for errors. This helper will streamline our error checks below.</td>
    <td class=code><pre class="prettyprint">func check(e error) {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	if e != nil {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">		panic(e)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">func main() {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=3>
         Perhaps the most basic file reading task is slurping a file&#39;s entire contents into memory.</td>
    <td class=code><pre class="prettyprint">	dat, err := ioutil.ReadFile(&#34;/tmp/dat&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Print(string(dat))</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         You&#39;ll often want more control over how and what parts of a file are read. For these tasks, start by `Open`ing a file to obtain an `os.File` value.</td>
    <td class=code><pre class="prettyprint">	f, err := os.Open(&#34;/tmp/dat&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         Read some bytes from the beginning of the file. Allow up to 5 to be read but also note how many actually were read.</td>
    <td class=code><pre class="prettyprint">	b1 := make([]byte, 5)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	n1, err := f.Read(b1)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Printf(&#34;%d bytes: %s\n&#34;, n1, string(b1[:n1]))</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=7>
         You can also `Seek` to a known location in the file and `Read` from there.</td>
    <td class=code><pre class="prettyprint">	o2, err := f.Seek(6, 0)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	b2 := make([]byte, 2)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	n2, err := f.Read(b2)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Printf(&#34;%d bytes @ %d: &#34;, n2, o2)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Printf(&#34;%v\n&#34;, string(b2[:n2]))</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=6>
         The `io` package provides some functions that may be helpful for file reading. For example, reads like the ones above can be more robustly implemented with `ReadAtLeast`.</td>
    <td class=code><pre class="prettyprint">	o3, err := f.Seek(6, 0)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	b3 := make([]byte, 2)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	n3, err := io.ReadAtLeast(f, b3, 2)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Printf(&#34;%d bytes @ %d: %s\n&#34;, n3, o3, string(b3))</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         There is no built-in rewind, but `Seek(0, 0)` accomplishes this.</td>
    <td class=code><pre class="prettyprint">	_, err = f.Seek(0, 0)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         The `bufio` package implements a buffered reader that may be useful both for its efficiency with many small reads and because of the additional reading methods it provides.</td>
    <td class=code><pre class="prettyprint">	r4 := bufio.NewReader(f)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	b4, err := r4.Peek(5)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	check(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Printf(&#34;5 bytes: %s\n&#34;, string(b4))</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         Close the file when you&#39;re done (usually this would be scheduled immediately after `Open`ing with `defer`).</td>
    <td class=code><pre class="prettyprint">	f.Close()</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

</table>
    <center><a href=../>index</a></center>
</body>
