<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="main.css">

<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(68262424, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/68262424" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/src/lang-go.js"></script>
<body>
    <center><a href=../>index</a></center>
<table>

<tr class=withcomment>
    
    <td class=comment rowspan=1>
         Go offers built-in support for [regular expressions](http://en.wikipedia.org/wiki/Regular_expression). Here are some examples of  common regexp-related tasks in Go.</td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">package main</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=6>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">import (</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;bytes&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;fmt&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;regexp&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">func main() {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         This tests whether a pattern matches a string.</td>
    <td class=code><pre class="prettyprint">	match, _ := regexp.MatchString(&#34;p([a-z]&#43;)ch&#34;, &#34;peach&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(match)</pre></td>
    <td class=output><pre class=preo>true
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Above we used a string pattern directly, but for other regexp tasks you&#39;ll need to `Compile` an optimized `Regexp` struct.</td>
    <td class=code><pre class="prettyprint">	r, _ := regexp.Compile(&#34;p([a-z]&#43;)ch&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Many methods are available on these structs. Here&#39;s a match test like we saw earlier.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.MatchString(&#34;peach&#34;))</pre></td>
    <td class=output><pre class=preo>true
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         This finds the match for the regexp.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindString(&#34;peach punch&#34;))</pre></td>
    <td class=output><pre class=preo>peach
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         This also finds the first match but returns the start and end indexes for the match instead of the matching text.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindStringIndex(&#34;peach punch&#34;))</pre></td>
    <td class=output><pre class=preo>[0 5]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         The `Submatch` variants include information about both the whole-pattern matches and the submatches within those matches. For example this will return information for both `p([a-z]&#43;)ch` and `([a-z]&#43;)`.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindStringSubmatch(&#34;peach punch&#34;))</pre></td>
    <td class=output><pre class=preo>[peach ea]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Similarly this will return information about the indexes of matches and submatches.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindStringSubmatchIndex(&#34;peach punch&#34;))</pre></td>
    <td class=output><pre class=preo>[0 5 1 3]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         The `All` variants of these functions apply to all matches in the input, not just the first. For example to find all matches for a regexp.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindAllString(&#34;peach punch pinch&#34;, -1))</pre></td>
    <td class=output><pre class=preo>[peach punch pinch]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         These `All` variants are available for the other functions we saw above as well.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindAllStringSubmatchIndex(</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">		&#34;peach punch pinch&#34;, -1))</pre></td>
    <td class=output><pre class=preo>[[0 5 1 3] [6 11 7 9] [12 17 13 15]]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Providing a non-negative integer as the second argument to these functions will limit the number of matches.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.FindAllString(&#34;peach punch pinch&#34;, 2))</pre></td>
    <td class=output><pre class=preo>[peach punch]
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Our examples above had string arguments and used names like `MatchString`. We can also provide `[]byte` arguments and drop `String` from the function name.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.Match([]byte(&#34;peach&#34;)))</pre></td>
    <td class=output><pre class=preo>true
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         When creating global variables with regular expressions you can use the `MustCompile` variation of `Compile`. `MustCompile` panics instead of returning an error, which makes it safer to use for global variables.</td>
    <td class=code><pre class="prettyprint">	r = regexp.MustCompile(&#34;p([a-z]&#43;)ch&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(r)</pre></td>
    <td class=output><pre class=preo>p([a-z]&#43;)ch
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         The `regexp` package can also be used to replace subsets of strings with other values.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(r.ReplaceAllString(&#34;a peach&#34;, &#34;&lt;fruit&gt;&#34;))</pre></td>
    <td class=output><pre class=preo>a &lt;fruit&gt;
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         The `Func` variant allows you to transform matched text with a given function.</td>
    <td class=code><pre class="prettyprint">	in := []byte(&#34;a peach&#34;)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	out := r.ReplaceAllFunc(in, bytes.ToUpper)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(string(out))</pre></td>
    <td class=output><pre class=preo>a PEACH
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

</table>
    <center><a href=../>index</a></center>
</body>
