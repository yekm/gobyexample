<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="main.css">

<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(68262424, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/68262424" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/src/lang-go.js"></script>
<body>
    <center><a href=../>index</a></center>
<table>

<tr class=withcomment>
    
    <td class=comment rowspan=1>
         URLs provide a [uniform way to locate resources](https://adam.herokuapp.com/past/2010/3/30/urls_are_the_uniform_way_to_locate_resources/). Here&#39;s how to parse URLs in Go.</td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">package main</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=6>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">import (</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;fmt&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;net&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	&#34;net/url&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=2>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">func main() {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         We&#39;ll parse this example URL, which includes a scheme, authentication info, host, port, path, query params, and query fragment.</td>
    <td class=code><pre class="prettyprint">	s := &#34;postgres://user:pass@host.com:5432/path?k=v#f&#34;</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         Parse the URL and ensure there are no errors.</td>
    <td class=code><pre class="prettyprint">	u, err := url.Parse(s)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	if err != nil {</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">		panic(err)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=1>
         Accessing the scheme is straightforward.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(u.Scheme)</pre></td>
    <td class=output><pre class=preo>postgres
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         `User` contains all authentication info; call `Username` and `Password` on this for individual values.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(u.User)</pre></td>
    <td class=output><pre class=preo>user:pass
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(u.User.Username())</pre></td>
    <td class=output><pre class=preo>user
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	p, _ := u.User.Password()</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(p)</pre></td>
    <td class=output><pre class=preo>pass
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=4>
         The `Host` contains both the hostname and the port, if present. Use `SplitHostPort` to extract them.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(u.Host)</pre></td>
    <td class=output><pre class=preo>host.com:5432
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	host, port, _ := net.SplitHostPort(u.Host)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(host)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(port)</pre></td>
    <td class=output><pre class=preo>host.com
5432
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=2>
         Here we extract the `path` and the fragment after the `#`.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(u.Path)</pre></td>
    <td class=output><pre class=preo>/path
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(u.Fragment)</pre></td>
    <td class=output><pre class=preo>f
</pre></td>
</tr>

<tr class=space>
    
    <td class=comment rowspan=1>
        </td>
    <td class=code><pre class="prettyprint"></pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=comment rowspan=5>
         To get query params in a string of `k=v` format, use `RawQuery`. You can also parse query params into a map. The parsed query param maps are from strings to slices of strings, so index into `[0]` if you only want the first value.</td>
    <td class=code><pre class="prettyprint">	fmt.Println(u.RawQuery)</pre></td>
    <td class=output><pre class=preo>k=v
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	m, _ := url.ParseQuery(u.RawQuery)</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(m)</pre></td>
    <td class=output><pre class=preo>map[k:[v]]
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">	fmt.Println(m[&#34;k&#34;][0])</pre></td>
    <td class=output><pre class=preo>v
</pre></td>
</tr>

<tr class=codeline>
    
    <td class=code><pre class="prettyprint">}</pre></td>
    <td class=output><pre class=preo></pre></td>
</tr>

</table>
    <center><a href=../>index</a></center>
</body>
